% Proc jsem delali rozhodnuti kdyz vznikala ta implementace.
\chapter{Analýza implementace}
V této kapitole prozkoumáme jaké rozhodnutí byla udělána během implementace a odůvodníme jejich zvolení. Prvně nahlédneme na abstrakční vrstvu a poté na samotnou hru.

% analyza abstrakce
\section{Analýza abstrakční vrstvy}
Abstrakční vrstva pro nás je důležitá, jelikož chceme aby naše hra byla nezávislá na konkrétní ECS knihovně. Program jako takový bude pracovat namísto ECS knihovny pouze s touto abstrakční vrstvou. Pro každou ECS knihovnu, kterou budeme měřit bude nutné vytvořit implementaci této vrstvy. K volbě konkrétní ECS knihovny dojde před spuštěním programu.

\subsection{Rozhraní ECS knihoven}
Pro návrh abstrakční vrstvy bude nejprve nutné rozebrat jak jsou jednotlivé prvky ECS reprezentovány při jejich implementaci. Krom základních členů, jako jsou \textit{entity}, \textit{komponenty} a \textit{systémy}, si představíme ještě \textit{world} a \textit{query}.

\begin{enumerate}
    \item \textbf{Component} \textit{Komponenty}, jako takové, bývají často reprezentovány třídou nebo strukturou. Jak již bylo zmíněno v úvodu, \textit{komponenty} obsahují pouze data, nikoliv žádnou logiku. Proto tyto třídy a struktury neobsahují žádné funkce.

    \item \textbf{Entity} \textit{Entita} by, podobně jako v návrhovém vzoru Component, mohla být reprezentována jako kolekce svých \textit{komponent}. Ovšem to se v praxi nedělá, namísto toho se používá řešení, které vede k lepšímu výkonu. Většina ECS implementacích reprezentuje \textit{entity} pouze jako jednoduchý identifikátor a jednotlivé \textit{komponenty} jsou na \textit{entity} mapovány skrze \textit{world}.

    \item \textbf{World} \textit{World} je spravce \textit{entit} a \text{komponent}. Tento správce slouží jako kontejner pro všechny \textit{entity} a \textit{komponenty} v herním světě. Jeho rozhraní nabízí funkce, pomocí niž je možné vytvářet a mazat jednotlivé entity. Často obsahuje také funkce pro přidávání a odebírání komponent jednotlivým entitám.

    Některé ECS implementace reprezentují entity pomocí malé struktury, obsahující identifikátor dané entity společně s referencí na world do kterého patří. To umožňuje mít na této struktuře bohaté rozhraní s funkcemi pro přidávání a odebírání komponent.

    \item \textbf{System} Reprezentace \textit{systémů} se v jednotlivých ECS implementacích dost liší. Některé vyžadují aby \textit{systém} byl třída dědicí od abstraktního předka, jiné zase volí opačný extrém a dovolují \textit{systém} reprezentovat téměř jakkoliv. Navzdory velkým odlišnostem se ve velkém počtu ECS implementací často objevuje objekt, který mohou používat jednotlivé systémy pro iterování entit s určitou množinou komponent.

    \item \textbf{Query} \textit{Query} je objekt, který lze použít pro iterování \textit{entit} s určitou množinou \textit{komponent}. Pro jeho vytvoření je většinou nutné poskytnou informaci, nad jakými typy \textit{komponent} bude \textit{query} pracovat. Je například možné mít \textit{query}, které pracuje nad \textit{komponentami} \verb|Movement| a \verb|Position|. Takové \textit{query} by pak bylo schopné iterovat nad všemi \textit{entitami} co mají \textit{komponenty} \verb|Movement| a \verb|Position|. Pomocí tohoto \textit{query} by bylo možné implementovat \verb|MovementSystem|, který by řídil logiku pohybu.
\end{enumerate}

Jak již bylo zmíněno, způsoby jakými jednotlivé ECS knihovny reprezentují \textit{systémy} se dost liší. Rozeberme si nyní tyto způsoby.

\begin{enumerate}
    \item \verb|Query((entity) => { /**/ })|
    \item \verb|Query((component1, component2) => { /**/ })|
    \item \verb|Query((components1[], components2[]) => { /**/ })|
    \item \verb|void Update(entity) { /**/ }|
    \item \verb|void Update(component1, component2) { /**/ }|
    \item \verb|void Update(components1[], components2[]) { /**/ }|
    \item \verb|foreach (entity in entities) { /**/ }|
    \item \verb|foreach ((component1, component2) in entities) { /**/ }|
    \item \verb|for (int i = 0; i < entitiesCount; i++)|\\\verb|{ components1[i], components2[i], /**/ }|
\end{enumerate}

Tyto způsoby lze rozdělit do tří kategorií.

Do první kategorie spadají způsoby 1--3. Knihovny, které využívají tyto způsoby mají většinou definovanou metodu \verb|Query| (neplést s \textit{query} jako objektem pro iterování \textit{entit}). Tato metoda bývá často implementována na \textit{query} nebo na \textit{world}. Této metodě se předává lambda funkce, která je v případě 1 volána na každou iterovanou \textit{entitu}, v případě 2 volána na množinu žádoucích instancí \textit{komponent} každé iterované \textit{entity}, v případě 3 volána na množinu polí, které obsahují žádoucí instance \textit{komponent} a kde jako index do těchto polí lze použít identifikátor příslušné \textit{entity}.

Způsoby z druhé kategorie vyžadují aby \textit{systém} byl třída, dědicí od rozhraní nebo předka. Toto rozhraní nebo předek nabízí abstraktní metodu \verb|Update|, kterou je nutné přetížit. Do této kategorie spadají způsoby 4--6. Při iteraci je v případě 4 metoda \verb|Update| volána na každou iterovanou \textit{entitu}, v případě 5 na množinu žádoucích instancí \textit{komponent} každé iterované \textit{entity}, v případě 6 na množinu polí, které obsahují žádoucí instance \textit{komponent} a kde jako index do těchto polí lze použít identifikátor příslušné \textit{entity}.

Třetí kategorie nabízí kolekce nebo iterátory, které lze iterovat. Tyto kolekce nebo iterátory lze získat voláním příslušné funkce na \textit{world} nebo \textit{query}. Do této kategorie spadají způsoby 7--9. V případě 7 tato kolekce nebo iterátor obsahuje všechny \textit{entity}, které chceme iterovat. V případě 8 tato kolekce nebo iterátor obsahuje n-tice žádoucích instancí \textit{komponent} každé iterované \textit{entity}. V případě 9 je namísto kolekce použita množina polí, které obsahují žádoucí instance \textit{komponent} a kde jako index do těchto polí lze použít identifikátor příslušné \textit{entity}.

\subsection{Inlinování funkce}
Při pohledu na způsoby, kterými jednotlivé ECS knihovny reprezentují systémy přirozeně vyplývá pro každou entitu zavolat funkci (konkrétně na místě komentáře \verb|/**/|), která danou entitu zpracuje. Ovšem volání funkce nás stojí čas. Tento čas není moc velký a je většinou zanedbatelný s porovnáním s časem vykonávání funkce samotné. Ovšem my bychom chtěli volat funkci pro každou žádoucí entitu a v případě, že by tato funkce byla jednoduchá (její vykonání by trvalo malé množství času), tak se jednotlivé časy volání této funkce nasčítají a naše řešení by vedlo ke ztrátě na výkonu.

Některé ECS knihovny se snaží tomuto problému předejít tím, že namísto toho aby jejich systémy přijímali funkci, kterou zavolají na každou entitu, poskytnou uživateli kolekce nebo iterátory, které si uživatel sám zpracuje. Tím se volání funkce vyhnou úplně. Znamená to tedy, že náš způsob ublíží na výkonu pouze některým knihovnám a to by mělo vliv na naše porovnání. Konkrétně se jedná o způsoby 3, 6, 7, 8 a 9 z minulé sekce.

JIT používá optimalizace, při které se nahradí místo volání funkce samotným obsahem dané funkce. Díky tomu může být volání takovéto funkce zadarmo. Konkrétně se jedná o takzvané \textit{inlinování funkce} (\textit{inline expansion}). Ovšem JIT tuto optimalizaci ne vždy provede, jelikož v některých případech se to nevyplatí nebo to dokonce udělat nemůže.

Pro více informací o tom kdy dochází a nedochází k \textit{inlinování funkcí}, je možné nahlédnout do článků od David Notario~\cite{Notario_2004} a Vance Morrison~\cite{Morrison_2008}. Konkrétně pro nás jsou důležité dva body.

\begin{enumerate}
    \item K \textit{inlinování funkce} nedojde, pokud se jedná o virtuální volání funkce.
    \item K \textit{inlinování funkce} nedojde, pokud je kód dané funkce příliš velký.
\end{enumerate}

Je nutné zmínit, že tyto články jsou již starší a nyní jsou pravidla pro inlinování méně přísná. Například JIT je schopný v některých případech provést \textit{inlinování funkce} i přes to, že se jedná o virtuálního volání funkce.

\subsection{Reprezentace systémů}
Jak již bylo v minulé sekci naznačeno, každý systém bude mít tedy funkci, kterou bude volat na každou entitu. Zároveň každý systém iteruje jednotlivé entity jiným způsobem. Systémy tedy budeme reprezentovat tím, že si pořídíme dva prvky.

\begin{enumerate}
    \item \textbf{EntityProcessor} První nazvěme \verb|EntityProcessor|. Ten bude mít na sobě již zmiňovanou funkci, nazvěme ji \verb|Process|, pro zpracování jedné entity.
    \item \textbf{IECSSystem} Druhý nazvěme \verb|IECSSystem|. Jedná se o rozhraní. Pro každou ECS knihovnu, kterou budeme chtít měřit, implementujeme třídu, která hude dědit od tohoto rozhraní. Toto rozhraní bude nabízet metodu \verb|Update| ve které implementujeme iteraci přes jednotlivé entity. Každá instance takového systému bude mít také instanci \verb|EntityProcessor|, jejíž \verb|Process| metodu při iteraci zavolá na jednotlivé entity.
\end{enumerate}

Tím jsme vyřešili různé reprezentace systému, ale ještě zbývá problém s \textit{inlinováním funkce}. Vyřešíme to tím, že jednotlivé \verb|EntityProcessor| budou struktury, které budou dědit od rozhraní \verb|IEntityProcesor|. Instance systému poté přijme typ konkrétního \verb|EntityProcessor| jako generický argument.

Nyní si vysvětlíme proč je pro nás důležité, že jednotlivé \verb|EntityProcessor| jsou struktury.

Když se vytváří konkrétní specializace pro generickou třídu či metodu, tak v případě parametru, který je struktura, dochází k procesu zvanému \textit{monomorfizace} (\textit{monomorphization}). Při \textit{monomorfizaci} se pro daný generický argument, který je hodnotového datového typu, vytvoří specializace dané třídy či metody, ve které je generický argument přímo nahrazen daným typem. Je nutné poznamenat, že k \textit{monomorfizaci} dochází pouze v případě dosazení typu, který je hodnotového typu (neboli jedná se o strukturu). V případě referenčního datového typu se vytváří pouze jedna jediná specializace, která daný generický argument nahrazuje typem \verb|object|.

Při použití konkrétního systému, kterému předáme jako generický argument jeden z \verb|EntityProcessor| dojde tedy k \textit{monomorfizaci}. Konkrétně dojde k vytvoření specializace pro již zmiňovanou metodu \verb|Update|. Tato specializace iteruje jednotlivé entity a na každé z nich volá metodu \verb|Process| na konkrétním \verb|EntityProcessor|. Na tomto volání může JIT provést \textit{inlinování}.

Může se stát, že metoda \verb|Process| na konkrétním \verb|EntityProcessor| bude příliš velká a nedojde k jejímu \textit{inlinování}. Tomu můžeme napomoci s použitím atributu \verb|MethodImplOptions.AggressiveInlining|~\cite{MethodImplOptions}, který JITu napoví, že bychom chtěli konkrétní metodu \textit{inlinovat} při jakémkoliv volání. Jedním z efektů při použití tohoto atributu je, že dojde k navýšení velikosti kódu, při které je kód dané funkce považován za příliš velký pro \textit{inlinování}. Může se stát, že velikost kódu dané funkce bude i po použití tohoto atributu příliš vysoká. V takovém případě ale bude cena vykonání dané funkce výrazně vyšší než její volání. 

\subsection{Component tag}
Některé ECS knihovny potřebují před spuštěním hry vědět o typech komponent.

Component tag jako řešení.

\subsection{ECSFactory}
Je nějak potřeba konstruovat implementace tříd z abstrakční vrstvy.

Konstrukce systémů je ukecaná.

ECSFactory jako řešení.

\section{Analýza hry}
Budeme chtít používat ai pro chování vesničanů.

\subsection{Umělá inteligence}
Způsoby reprezentace ai:

\begin{enumerate}
    \item Stavové automaty
    \item Stromy chování
    \item GOAP
\end{enumerate}

Proč jsme zvolili stromy chování.

Použili jsme knihovnu na stromy chování.

Umělou inteligenci je možné definovat také v systémech.

Ne vždy je zřejmé co by mělo či nemělo být součástí umělé inteligence.

Tezba surovin: připsání do inventáře vs damage and drop systém.

Zpracování surovin: připsání do inventáře vs resource processing systém. 

\subsection{ECS}
Některé systémy proběhnou pro danou entitu pouze pokud je pro ní splněna určitá podmínka.

Podmínka je drahá operace protože pipeline flush.

Řešením můžou být eventy. EventQueue, EventReader/EventWriter, csharp events.

Další možné řešení jsou reaction systémy.

Proč eventy a reaction systémy nemůžeme použít. Proč nepoužíváme csharp eventy.

Proč tyto systémy nezpůsobují výkonnostní potíže při správných podmínkách (+ ty podmínky).

\subsection{Procedurální terén}
Terén generován pomocí simplex noise.

\subsubsection{Generování terénu na CPU}
Zápis do jedné nebo více textur.

Rozmazání při přiblížení nebo oddálení.

Může trvat dlouho.

\subsubsection{Generování terénu na GPU}
Shadery jsou programy pro GPU. V této práci použijeme fragment shader a compute shader.

Shader pro generování terénu.

Je možné libovolně přiblížit nebo oddálit.

Provádíme za běhu a velmi rychle.

Z právě techto důvodů GPU.

\subsection{Path-finding pro vygenerovaný terén}
Při CPU přístupu by stačilo číst z textury.

Chceme pěkné cesty, takže výslednou cestu zkrášlujeme.

Vygenerovat texturu by trvalo dlouho, proto použijeme compute shader.

Zvolíme rozlišení, které předsamplujeme do pole, ve kterém poté provádíme path-finding.

Generování může trvat, protože přesun dat mezi GPU a CPU je drahý.

Je nutné použít fork MonoGame, který podporuje compute shadery.












% \subsection{Reprezentace systémů}
% Jak již bylo zmíněno v úvodu, velký problém při návrhu systémů je rozdílné rozhrani, které pro systémy jednotlivé ecs knihovny nabízejí.

% Dále, jak již jsme si zmiňovali v podkapitole o herních požadavcích, chceme aby se výkon naší hry při použití této abstrakční vrstvy blížil výkonu s použitím pouze samotné ecs knihovny.

% Nahlédneme na oba tyto problémy blíže a prozkoumáme jak jsme je vyřešili.

% \subsubsection{Rozhraní ecs knihoven}
% ECS knihovny reprezentují systémy následujícími způsoby:

% \begon{ordering}
% \item \xxx{TODO}
% \end{ordering}











% V této sekci si představíme knihovny, které budeme chtít měřit. Nahlédneme na jejich rozhraní a na základě toho odůvodníme rozhodnutí provedené při implementaci abstrakční vrstvy.

% % - knihovny
% \subsection{Měřené knihovny}
% Než začneme provádět analýzu abstrakční vrstvy, musíme si nejprve představit jednotlivé knihovny, které budeme chtít měřit. Následně nahlédneme na jejich rozhraní, to nám pomůže při analýze abstrakční vrstvy.

% % --- predstaveni knihoven
% I přesto, že lze program použít pro měření velkého množství ECS knihoven pro C\#, omezíme se pouze na následující:

% \begin{enumerate}
%     \item Arch~\cite{Arch}
%     \item DefaultEcs~\cite{DefaultEcs}
%     \item Entitas~\cite{Entitas}
%     \item HypEcs~\cite{HypEcs}
%     \item LeoECS~\cite{LeoECS}
%     \item \xxx{Pridat dalsi knihovny kdyz bude cas.}
% \end{enumerate}

% \xxx{ --- rozebrat interface knihoven}\\\\

% \section{Inline entity processor}

% Inlinování funkcí je optimalizace, při které je volání funkce nahrazeno jejím obsahem.

% % priklad, kdy dochazi k inlinovani

% Kvůli měření je důležité, aby naše entity procesory neměli ideálně žádný overhead.

% Pro inlinování entity procesorů, využíváme následující techniky.

% % aggressive inlining, struktura + generika

% % \\
% % \xxx{Proc je to potreba}
% % \\
% % \xxx{Jak jsme toho dosahli}
% % \\

% \xxx{ - entity processor}\\\\
% \xxx{ --- -> entity processor}\\\\
% \xxx{ --- co je inline function call}\\\\
% \xxx{ --- jak jej zaridit}\\\\
% \xxx{ --- -> proto struktura a generika (IECSSystem)}\\\\

% \xxx{ - IEntity (chceme bohate rozhrani, jak jsme si popisovali)}\\\\
% \xxx{ - IWorld (nektere ECS knihovny potrebuji Update/Tick)}\\\\
% \xxx{ - Component attribute}\\\\
% \xxx{ - ECSFactory (proc types - zjednoduseni rozhrani)}\\\\

% \section{Analýza hry}

% text

% \subsection{Implementace AI}

% Nyní si rozebereme populární přístupy pro implementaci AI ve hrách.

% Nejpřímočařejší způsob je použít stavové automaty.

% Pokročilejší zpusob jsou behavior trees.

% Další pokročilejší způsob je Goal Oriented Action Planning (GOAP).

% Proč jsme zvolili behavior trees?

% Chování AI agentů může být popsané také přímo v systémech.

% Ne vždy je zřejmé co by mělo být součástí AI.

% \\
% \xxx{jaka jsou mozsnosti?}
% \\
% \xxx{- behavior trees}
% \\
% \xxx{- state machines}
% \\
% \xxx{- GOAP}
% \\
% \xxx{proc jsme zvolili behavior trees?}
% \\
% \xxx{behavior primo v systemech a proc jsme to nepouzili}
% \\
% \xxx{Co by melo byt rizeno AI a co ne?}
% \\
% \xxx{- tezba surovin: pripsani do inventare vs damage and drop system}
% \\
% \xxx{- zpracovani surovin: pripsani do inventare vs resource processing system}
% \\

% \subsection{ECS}

% Některé systémy v ECS reagují pouze pokud je pro danou entitu splněna určitá podmínka.

% Na první pohled by se mohlo zdát, že jsou tyto systémy špatné, jelikož podmínka je drahá operace.

% Alternativní a pravděpodobně lepší způsob je použít eventy.

% Rozeberme si jak by se s eventy v ECS pracovalo.

% Další způsob, jak by se tento problém dal řešit jsou Reaction systémy.

% \\
% \xxx{condition checking systems are ok}
% \\
% \xxx{eventy v ECS}
% \\

% \subsection{Generovani terenu}

% Rozeberme si dva přístupy pro generování terénu.

% První způsob je generovat terén přímo na CPU.

% Druhý způsob je pro generování terénu použít GPU.

% problem s path finding

% Abychom si rozebrali řešení, bude nejprve nutné nejprve říci něco více o shaderech.

% Compute shader můžeme použít k řešení výše zmíněného problému.

% \xxx{GPU vs CPU}
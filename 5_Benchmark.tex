\chapter{Měření}
Náš projekt se skládá ze dvou částí a to hry a poté měření, které využívá vytvořenou hru pro měření výkonu jednotlivých ECS knihoven. Analýzu tohoto měření jsme provedli v sekci~\ref{benchmark-analysis} a jeho implementaci jsme popsali v sekci~\ref{benchmark-implementation}. V této kapitole si nejprve stanovíme hypotézu, poté si přiblížíme ECS knihovny, které budeme měřit a na závěr si prezentujeme výsledky tohoto měření.

\section{Hypotéza}
\label{chap:hypothesis}
V této sekci si stanovíme hypotézu našeho měření. V našem měření měříme jak dlouho trvá odsimulovat určitý počet iterací naší hry s jednotlivými ECS knihovnami. Ty se dají rozdělit na kategorie podle určitých vlastností. V této kapitole stanovíme jak si myslíme, že se jednotlivé kategorie umístí.

% Do teď jsme se věnovali samotné hře, kterou v následujících kapitolách budeme chtít použít pro porovnání výkonu ECS knihoven. Ale ještě předtím, konkrétně v této kapitole, si rozebereme předpokládané výsledky tohoto porovnání.

\subsection{Cache}
Využití cache je klíčový faktor pro výkon ECS knihovny, proto si nyní připomene co to vlastně je a jak funguje.

Program si svoje data uchovává v paměti RAM. Ovšem přístup do této paměti je z hlediska času drahý. Pro představu u moderních pamětí takovíto přístup může trvat vyšší desítky nanosekund. Z tohoto důvodu se využívají menší paměti, takzvané cache, které disponují mnohem vyšší rychlostí ale mnohem menší velikostí. Pro představu moderní procesory používají cache, u kterých přístup může trvat menší desetiny nanosekund.

Při přístupu k datům se procesor nejprve podívá zda nemá data již v této cache. Pokud ano, jedná se o takzvaný \textit{cache hit} a data si z ní načte. Pokud ne, jedná se o takzvaný \textit{cache miss} a je nutné data načíst z hlavní paměti. 

Již víme, že \textit{cache miss} jsou drahé, proto je potřeba pro vysoký výkon je minimalizovat. Ale jak přesně procesor rozhoduje o tom, jaká data budou v cache a jaká ne. Využívá se takzvané \textit{časové} a \textit{prostorové lokality}. \textit{Časová lokalita} spočívá v tom, že pokud jsme přistoupili k nějakým datům, je velká šance, že k nim brzo budeme chtít přistoupit znovu. Nadruhou stranu \textit{prostorová lokalita} spočívá v tom, že pokud jsme přistoupili k nějakým datům, je velká šance, že budeme chtít přistoupit také k datům, které se nacházejí blízko nich.

Jedna z možností, jak minimalizovat počet \textit{cache miss}, je využít sekvenčního přístupu. Pokud budeme přistupovat k datům, které jsou v paměti hned za sebou, tak díky \textit{prostorové lokalitě} bude počet \textit{cache miss} velmi malí.

Je nutné upozornit, že výše popsaný model cache je úmyslně zjednodušen. Velice detailní popis cache lze nalézt v \textit{Cache Memories}~\cite{10.1145/356887.356892} od \textit{Alana Jaye Smitha}. Stručnější popis a také informace o tom jak lze cache využít lze nalézt v již zmiňované knize \textit{Game Programming Patterns}~\cite{nystrom2014game}, konkrétně v kapitole \textit{Data Locality}. 

\subsection{Arch type}
Některé ECS knihovny pro lepší výkon používají \textit{arch type}. Jedná se o datovou strukturu pro ukládání komponent. Knihovny, které používají tuto datovou strukturu mají většinou velký výkon, proto před stanovením hypotézy si použití \textit{arch type} lehce přiblížíme.

Jak již bylo zmíněno, \textit{arch type} je datová struktura. Tato datová struktura představuje typ entity. Tento typ je jednoznačně určen typy všech komponent dané entity. Je možné si jej představit jako tabulku, kde jednotlivé sloupečky odpovídají komponentám a v každém řádku se nacházejí instance komponent pro danou entitu. Například můžeme mít \textit{arch type} vyobrazený v tabulce~\ref{tab:arch-type}. Tento \textit{arch type} je jednoznačně určen typy komponent \texttt{Position} (představující pozici entity), \texttt{Health} (představující počet životů entity) a \texttt{Damage} (představující poškození, které entita může udělit jiné entitě).

\begin{table}[!htb]
    \centering\footnotesize\sf
    \begin{tabular}{c c c c}
        \toprule
        entita & \texttt{Position} & \texttt{Health} & \texttt{Damage} \\
        \midrule
        hráč & $(0,0)$ & 10 & 3 \\
        nepřítel & (5,4) & 6 & 1 \\
        npc & (-4,8) & 16 & 9\\
        \bottomrule
    \end{tabular}
    \caption{Tabulka vyobrazující \textit{arch type}, který je jednoznačně určen komponentami \texttt{Position}, \texttt{Health} a \texttt{Damage}. Tento \textit{arch type} obsahuje tři entity, konkrétně hráče, nepřítele a npc.}
    \label{tab:arch-type}
\end{table}

Jednotlivé \textit{arch type} jsou uloženy ve \textit{world}. Každý \textit{arch type} má v sobě několik polí, konkrétně jedno pole pro každý typ komponenty. V každém poli jsou poté uloženy instance příslušných komponent. V případě \textit{arch type} z tabulky~\ref{tab:arch-type} by tento \textit{arch type} obsahoval jedno pole pro \texttt{Position} komponenty, jedno pole pro \texttt{Health} komponenty a jedno pole pro \texttt{Damage} komponenty.

Pokud bychom chtěli iterovat přes všechny entity s danými komponentami, stačilo by nám projít příslušná pole všech \textit{arch type} s těmito komponentami. Tato iterace by byla, díky sekvenčnímu přístupu zmíněnému v minulé sekci, velice rychlá. Ke \textit{cache miss} by docházelo pouze při přechodu na další \textit{arch type}.

Nevýhodou knihoven založených na \textit{arch type} bývá pomalé přidávání a odebírání komponent. Pokud je entitě přidána nebo odebrána komponenta, dojde ke změně jejího \textit{arch type}. Při této změně se vezmou instance všech komponent dané entity a přesunou se do nového \textit{arch type}.

Pro více informací o \textit{arch type} a o tom jak je ECS knihovny využívají je možné nahlédnout do série článků \textit{ECS back and forth}~\cite{Caini_2019} od Michela Cainiho.

\subsection{Hypotéza}
Nyní vyřkneme hypotézu. Jednotlivé ECS knihovny lze rozdělit do kategorií na základě jistých vlastností. My tyto kategorie popíšeme a stanovíme jaké bude jejich pořadí při výkonnostním porovnání.

Nejrychleji vyjdou ECS knihovny, které používají \textit{arch type}. Jak již bylo zmíněno, \textit{arch type} je datová struktura s kterou lze, díky malému počtu \textit{cache miss}, dosáhnout velkého výkonu při iteraci entit. Z těchto důvodů ECS knihovny, které \textit{arch type} používají vyjdou nejlépe.

Některé ECS knihovny vyžadují aby jednotlivé komponenty byli reprezentovány jako třídy. Tyto knihovny vyjdou nejhůře. V případě, že komponenta je třída, znamená to, že její proměnné musejí být pointery. Z toho důvodu iterace přes komponenty v těchto knihovnách vede ve velmi velký počet \textit{cache miss}, kvůli kterému se tyto knihovny umístí nejhůře. 

Zbývají knihovny, které povolují komponenty reprezentovat jako struktury, ale zároveň nepoužívají \textit{arch type}. Tyto knihovny se umístí hůře než knihovny, které používají \textit{arch type}, ale lépe než knihovny, které vyžadují aby komponenty byli třídy.

\section{Měřené knihovny}
V této sekci se budeme zabývat ECS knihovnami, které budeme měřit. První si uvedeme odkud měřené ECS knihovny bereme a poté si jednotlivé ECS knihovny krátce představíme.

V sekci~\ref{sec:ecs-libs} jsme zmínili, že existuje repositář \textit{EcsCsharpBenchmark}~\cite{EcsCsharpBenchmark} na platformě GitHub obsahující výkonnostní porovnání ECS knihoven pro C\#. Tento repositář byl inspirací této práce, která také porovnává jednotlivé ECS knihovny, ale na místo jednoduchých testů je porovnává na hře. V našem měření budeme měřit knihovny, které byli porovnávány ve zmiňovaném repositáři \textit{EcsCsharpBenchmark}~\cite{EcsCsharpBenchmark}.

Od zahájené této práce byl repositář \textit{EcsCsharpBenchmark}~\cite{EcsCsharpBenchmark} několikrát upraven. Během úprav byli přidávány a odebírány některé ECS knihovny z porovnání. V této práci se zaměříme na knihovny, které byli v repositáři \textit{EcsCsharpBenchmark}~\cite{EcsCsharpBenchmark} porovnávány během commitu \textit{db67d1d}~\cite{EcsCsharpBenchmarkCommit}.

Nyní si představíme jednotlivé ECS knihovny, které budeme měřit. U každého si uvedeme přeložený popisek, který je možné nalézt v repositáři dané knihovny. Tyto popisky jsou doslovně převzaté a autor práce neručí za korektnost informací, které jsou jejich obsahem.

\begin{enumerate}
    \item \textbf{Arch~\cite{Arch}:} Vysoko-výkonnostní ECS knihovna založená na Archtype určená pro herní vývoj a data-oriented programování.
    \item \textbf{DefaultEcs~\cite{DefaultEcs}:} ECS framework, který si klade za cíl být přístupný s minimálními omezeními, zatímco zachovává co největší výkon pro vývoj her.
    \item \textbf{Entitas~\cite{Entitas}:} Nejpopulárnější open-source ECS framework pro C\# a Unity.
    \item \textbf{HypEcs~\cite{HypEcs}:} Lightweight a snadno použitelná ECS knihovna s efektivní sadou funkcionalit pro tvorbu her.
    \item \textbf{LeoECS~\cite{LeoECS}:} Lightweight ECS framework pro C\#. Mezi hlavní cíle tohoto frameworku patří výkon, nulová nebo minimální alokace, minimalizace využití paměti a absence závislostí na jakémkoliv herním enginu. (Přeloženo přes ChatGPT.)
    \item \textbf{LeoEcsLite~\cite{LeoEcsLite}:} Lightweight ECS framework pro C\#. Mezi hlavní cíle tohoto frameworku patří výkon, nulová nebo minimální alokace, minimalizace využití paměti a absence závislostí na jakémkoliv herním enginu. (Přeloženo přes ChatGPT.)
    \item \textbf{MonoGameExtended.Entities~\cite{MonoGameExtended}:} Moderní vysoce výkonnostní ECS framework založený na Artemis.
    \item \textbf{RelEcs~\cite{RelEcs}:} Lightweight a snadno použitelná ECS knihovna s efektivní sadou funkcionalit pro tvorbu her.
    \item \textbf{Svelto.ECS:} Reálný ECS framework pro C\#. Umožňuje psát zapouzdřený, oddělený, udržovatelný, vysoce efektivní, datově orientovaný, cache-přátelský kód bez bolesti.
\end{enumerate}

\section{Výsledky}
V ttt jsme si povidali o ddd a vime ze budeme delat mereni. Mereni jsme si zanalyzovali v ooo a implementaci rozebrali v xxx. Nyní si rozebereme jeho vysledky.

Předtím než si prezentujeme časy měření tak schrneme jak jej provádíme. Vytvoříme si novou instanci hry (tridy Game) s danou ECS knihovnou (danou instancí třídy entityfactory) a necháme ji běžet přípravý počet iterací (x iterationcount). Poté jí necháme běžet měřený počet iterací (y iteraction count) a přitom měříme jak dlouho to trvá. Výsledný čas je tedy čas jak rychle hra zvládna simulovat měřený počet iterací. Test provádíme pro každou měřenou ECS knihovnu (ty jsem rozebrali v minule sekci).

Nyní si prezentujeme vžsledky tohoto měření

\begin{table}[!htb]
    \centering\footnotesize\sf
    \begin{tabular}{c c c c}
        \toprule
        knihovna & Průměrný čas & Chyba & StdDev \\
        \midrule
        HypEcs & 1.133 s & 0.0218 s & 0.0194 s \\
        LeoEcsLite & 1.194 s & 0.0188 s & 0.0176 s \\
        LeoECS & 1.208 s & 0.0233 s & 0.0229 s \\
        DefaultEcs & 1.216 s & 0.0243 s & 0.0451 s \\
        Svelto.ECS & 1.384 s & 0.0172 s & 0.0161 s \\
        Arch & 1.394 s & 0.0098 s & 0.0092 s \\
        RelEcs & 1.401 s & 0.0166 s & 0.0156 s \\
        MonoGameExtended.Entities & 2.004 s & 0.0340 s & 0.0318 s \\
        Entitas & 4.732 s & 0.0244 s & 0.0228 s \\
        \bottomrule
    \end{tabular}
    \caption{Výsledky měření pro jednotlivé ECS knihovny.}
    \label{tab:benchmark-results}
\end{table}

Tabulka zachycuje vysledne casy zachycene podle procedury vyse. V prvním sloupci je možné videt nazvy jednotlivých knihoven. Ve druhém sloupci casy jak dlouho simulace s konrkétní knihovnou trvala. Tretí sloupec je chyba. Ctvrty je stddev. Radky v tabulce jsou serazene podle 2. sloupce (prumerny cas).

V xxx jsme naznacili kategorie. Mezi knihovny co maji archtype patri HypEcs, LeoEcsLite, LeoECS, DefaultEcs a Arch. SveltoECS pouziva vlastni datovou strukturu, ktera je arhctype hodne podobna. Knihovna RelEcs je zvlastni a pouziva archtype a zaroven vyzaduje aby komponenty byli tridy. Spada do druhe kategorie. Treti kategorie vyzaduje aby komponenty byli tridy a nepouzivaji archtype. DO ni spada RelEcs a MonoGameExtended.Entities.

Na obrazku xxx je mozne videt 2 grafy. Graf nalevo jsou namerene vysledky vyzobrazene z tabulky vyse. Graf napravo je ten sami cas, akorat jsou vysledky pro jednotlive knihovny obarveny podle toho do jake kategorie spadaji.

graf 1 a graf 2

V yyy jsme si stanovli hypotezu podle kterych maji nejlepe vyjit archtype knihovny, pote jine knuihovny, pote class knihovny. Z grafu je lehke vykoukat ze tomu tak je. Je mozne videt ze casy pro jedntlive archtype jsou hodne podobne. Zaroven RelEcs ma class+archtype a take velmi podobny cas, takze pozadavek na struct komponenty nemusi nutne znamenat velke vykonostni zlepseni.

Zajimava knihvna je Svelto.ECS. Vyzaduje aby bylo za kompilace znamo jake budeme mit typy entit, presneji z jakych komponent se budou skladat. To hrozne ublizuje flexibilite. I presto tyto omezeni neprinasi velke vykonostni vylepseni.

Podle githubu je nejpopularnejsi knihovnou Entitas (ma na github nejvice hvezdice s porovnanim s osttanimi). I presto ze je nejpomalejsi tak vykon neni tak spatny. Nab9z9 tak0 velkou podporu pro herni engine Unity.
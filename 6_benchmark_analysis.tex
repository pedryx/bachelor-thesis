\chapter{Analýza měření}
V této kapitole provedeme analýzu rozhodnutí, která byla vykonána během implementace měření. Prvně nahlédneme na framework, který jsme k měření použili. Následně si rozebereme přístupy pro měření výkonu hry. Nakonec si řekneme na které věci při našem měření nebereme ohled.

\section{Benchmark.NET}
Měření výkonu je komplexní proces, který by mohl být prací sám o sobě.

Benchmark.NET je populární framework pro platformu .NET, který lze použít k měření výkonu.

\section{Přístupy k měření výkonu}

Nejprve je nutné si říct co to je vlastně game loop.

Nejpřímočařejší způsob je změřit jak dlouho trvá jedna iterace.

Lepší způsob by tedy bylo změřit n iterací a spočítat jejich průměr. To je také způsob, který jsme zvolili.

Rendering může být časově náročnější proces, rozeberme si jestli by měl či neměl být součástí měření.

Dalším způsobem jak měřit výkon, je změřit iterace jednotlivých systémů. Větší insight ale nevidíme overall výkon, ale mohl by být pomocný.

Výkon je také možné měřit během hraní samotné hry. Poskytuje insight pro jiné věci než chceme ale mohl by být pomocný.

\section{Co při měření nebereme v potaz}
Některé ECS knihovny pro získání lepšího výkonu používají paralelní queries.

Naše hra je nepoužívá protože je z jednoduchosti navržena single threaded.

Další častá optimalizace, co některé ECS knihovny nabízejí jsou již zmiňované reaction systémy.

My je nepoužíváme protože je né každá ecs knihovna podporuje.

Jednotlivé ECS knihovny často používají další specifické výkonnostní funkcionality.

My je nepoužíváme protože jsou ecs knihovna specific.
















% \chapter{Analýza měření}
% V této kapitole si rozebereme jaké existují přístupy k měření a na co při měření dbát ohled.

% \section{Problematika měření}
% Měření výkonu je komplexní proces, který by mohl být samostatnou prací sám o sobě.

% Benchmark.NET je populární framework pro platformu .NET, který lze použít k měření výkonu.

% \section{Přístupy k měření}
% Nejprve je nutné si říct co to je vlastně game loop.

% Nejpřímočařejší způsob je změřit jak dlouho trvá jedna iterace.

% Lepší způsob by tedy bylo změřit n iterací a spočítat jejich průměr.

% Rendering může být časově náročnější proces, rozeberme si jestli by měl či neměl být součástí měření.

% Dalším způsobem jak měřit výkon, je změřit iterace jednotlivých systémů.
% % proc to nedelame

% Výkon je také možné měřit během hraní samotné hry.
% % proc to nedelame

% % \xxx{Delta time jedne iterace}
% % \\
% % \xxx{Delta time n iteracich}
% % \\
% % \xxx{Mel by byt rendering soucasti mereni}
% % \\
% % \xxx{Mereni prumerneho delta time jednotlivych ssytemu}
% % \\
% % \xxx{Mereni behem hrani}

% \section{Na co při měření nebereme ohled?}
% Některé ECS knihovny pro získání lepšího výkonu používají paralelní queries.
% % co to je
% % nase hra je nepouziva protoze je z jednoduchosti navrzena single threaded

% Další častá optimalizace, co některé ECS knihovny nabízejí jsou reaction systémy.
% % co to je
% % nepouzivame to protoze to nemaji vsechny knihovny

% Jednotlivé ECS knihovny často používají další specifické výkonnostní funkcionality.
% % mi je nepouzivame protoze je nemaji vsechny knihovny

% Další věc na kterou při měření nebereme ohledy je přidávání a odebírání komponent.
% % sparse set muzou by zvyhodnene
% % nas herni design je prizpusoben tomu, ze to neovlivni mereni

% % \xxx{Paralelni queries}
% % \\
% % \xxx{Reaction systemy}
% % \\
% % \xxx{Pridavani/odebirani komponent za runtime - design prizpusoben}
% % \\
% % \xxx{jine vykonostni vylepseni specificke pro danou ECS knihovnu}
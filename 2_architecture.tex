\chapter{Architektury her}
V této kapitole si rozebereme architektury, které lze využít pro vývoj her. Pomůže nám to lépe porozumět problémům, které ECS řeší. Začneme objektovým návrhem a prozkoumáme problémy spojené s dědičností při vývoji her. Následně se zaměříme na návrhový vzor Component, který se snaží řešit tuto problematiku, a nahlédneme proč komunikace mezi komponentami může být problematická.

% Iterativni proces
Proto abychom lépe porozuměli herním architekturám, bude nutné si nejprve přiblížit jak se tvorba her liší od tvorby jiného typu softwaru. Vývoj her je iterativní proces, při kterém se nejprve navrhnou herní mechaniky. Následně probíhá testovaní, při kterém se zjistí, jestli jsou příslušné herní mechaniky zábavné. Pokud nejsou je nutné je upravit a znovu otestovat. Tyto dvě aktivity se opakují dokud vytvořené mechaniky nejsou dostatečně zábavné. V moment co jsou mechaniky vytvořené a víme o nich, že jsou zábavné, je možné vytvořit další mechaniky a celí proces opakovat. Takto se postupuje dokud nedojde k vytvoření celé hry.

% Co to implikuje?
Výše zmíněný iterativní proces, nám implikuje to, že zdrojový kód pro hry se mění velice často. Z toho důvodu je flexibilita velice důležitá vlastnost architektury při vývoji her.

\section{Objektový návrh}
% prirozenym zpusobem vyuzit bezneho objektoveho navrhu programovaciho jazyka, cili udelat nejakou sadu objektu provazanych dedicnosti
Přirozeným přístupem pro tvorbu software je použítí objektový návrh a s jeho pomocí si vytvořit sadu tříd provázaných dědičností. Ovšem jak již bylo naznačeno, v případě tvorby her může být tento přístup problematický.

% Jak se pouziva objektovy nabrh ve vyvoji her

Navrhneme si jednoduchou hru, na které si přiblížíme problémy s dědičností, které mohou při vývoji her s objektovým návrhem nastat. Budeme navrhovat jednoduchý tower defense \xxx{link}. Začneme třídou \verb|GameObject|, ta nám bude sloužit jako předek pro libovolný objekt ve scéně. Nyní bychom chtěli vytvořit jednotky, vytvoříme tedy třídu \verb|Unit|, která podědí od \verb|GameObject|. Chtěli bychom aby ve hře byli také speciální jednotky, které umí střílet, např. lučišníci. Vytvoříme tedy třídu \verb|Archer|, která dědí od třídy \verb|Unit|. Dále v naší hře budem potřebovat věže, uděláme tedy třídu \verb|Tower|, dědicí od třídy \verb|GameObject|. Určitě budem chtít od většiny našich věží aby uměli střílet, implementujeme tedy další třídu \verb|ShootingAbleTower|, dědicí od třídy \verb|Tower|. Do této třídy budem určitě chtít implementovat mechaniku střelby. Ovšem střelbu jsme již určitě implementovali do třídy \verb|Archer|, což nám nyní vytváří duplicitní kód.

\xxx{obrazek}

Jak tento problém vyřešit? Prvním přístupem je využití multiple inheritance \xxx{link} (vícenásobné dědičnosti). Pokud programovací jazyk povoluje multiple inheritance, umožňuje to jedné třídě mít více než jednoho předka. Pokud bychom chtěli pomocí multiple inheritence vyřešit náš problém, mohli bychom implementovat třídu \verb|ShootingAble|, která dědí od \verb|GameObject|. Do této třídy bychom implementovali mechaniku střelby. Náš \verb|Archer| by poté dědil od \verb|ShootingAble| a od \verb|Unit|. Naše \verb|ShootingAbleTower| by dědila od \verb|ShootingAble| a od \verb|Tower|.

\xxx{obrazek}

Tímto řešení by nám ale vznikl tzv. diamond problém \xxx{link}. Jedná se problém, který může vzniknout při používání multiple inheritance. Diamond problém nástává tehdy, pokud je potřeba přisoupit ke členům definovaných na společném předkovi. V našem případě se jedná o členy na třídě \verb|GameObject|.

Alternativním přístupem by mohlo být přesunutí společné logiky do společného předka. V našem případě bychom mechaniku střelby implementovali přímo ve třídě \verb|GameObject|.

Ovšem tímto porušíme jeden z principů objektového programování, konkrétně single responsibility \xxx{link}. Tento princip nám říká, že každá třída by měla být zodpovědná pouze za jednu věc. Porušení tohoto principu může mít za následek, že se nám ve společném předkovi začne hromadit velké množství logiky. To může vyústit v obrovskou třídu, která řeší všechny možné herné mechaniky. Jedná se o tzv. blob object \xxx{link}. 

Další problém je, že náš návrh je příliš závislý na hierarchii dědičnosti, což omezuje design naší hry. V praxi to znamená, že např. není možné za běhu přidat objektu schopnost střílet.

Řešením celé této situace je koncept composition over inheritance \xxx{link}. Tento princip nám říka, že namísto hluboké hierarchie dědičnosti bychom měli preferovat rozdělení objektů do komponent. Je to princip, na kterém je postavený návrhový vzor Component a také ECS.

\xxx{Pridat jako poznamku pod carou: Ve skutečnosti byl princip composition over inheritance zmíněný již v Gang of Four a jedná se o dobrou praktiku v objektovém programování. }

\section{Návrhový vzor Component}
\label{sec:component}
Component je návrhový vzor, který se často používá pro vývoj her. Používá jej velké množství herních frameworků a enginů, jako je např. Unity nebo MonoGame. Tento návrhový vzor je velice dobře popsán v~\citet{nystrom2014game}.
% Unreal, Unity, MonoGame
% odkaz na game programming patterns

% citace na component
Přibližme si co to vlastně je návrhový vzor Component. Máme nějákou entitu (neplést s entitou z ECS, která reprezentuje pouze objekty v herní scéně) např. hráče nebo přímo celou hru. Tato entita obsahuje několik domén. Pro hráče to můžou být logiky co řeší např. útok nebo pohyb. Pro hru to můžou být jednotlivé herní mechaniky, jako např. spawnování nepřátel nebo čtení vstupu z klávesnice. Abychom izolovali tyto domény, tak kód každé takové domény umístíme do samostatné komponenty. Tato komponenta může být reprezentována např. třídou. Entita jako taková je redukována na kontejner těchto komponent~\cite{nystrom2014game}.

\xxx{A single entity spans multiple domains. To keep the domains isolated, the code for each is placed in its own component class. The entity is reduced to a simple container of components.}

% Jeho pouziti se muze lisit
Je videt, že tento návrhový vzor je definován velice obecně. Jeho implementace a použítí se v praxi můžou lišit. Ve skutečnosti je tento návrhový vzor použit i v ECS, konkrétně pro komponenty jednotlivých entit. V této sekci se ale budem bavit o použití tohoto návrhového vzoru jako architektury pro vývoj her.

% Jak ho pouziva Unity
Nyní si přibližme jak se návrhový vzor Component používá v herním enginu Unity. V Unity je každý objekt ve scéně reprezentován třidou \verb|GameObject|. Každý takový objekt má interně v sobě kontejner, který obsahuje komponenty, kterými objekt disponuje. Důležitým typem komponenty, který entita může mít jsou skripty, kterými si uživatel Unity může dodefinovat chování pro jednotlivé herní objekty ve scéně. Každý takovýto skript dědí od abstraktní třídy \verb|MonoBehaviour|. Tyto skripty společně s komponenty, které na sobě jednotlivé herní objekty mohou mít, jsou typickým příkladem návrhového vzoru Component.

% Jak ho pouziva MonoGame
Na druhou stranu MonoGame, herní framework pro C\#, volí jiný způsob a jako danou entitu z definice zvolil hru samotnou. Jakákoliv herní komponenta dědí od abstraktní třídy \verb|GameComponent|. Hra má interní kolekci, kde uchovává všechny instance herních komponent. MonoGame má také abstraktní třídu \verb|DrawableGameComponent|, která dědí od \verb|GameComponent| a přidává herním komponentám, které od ní dědí, schopnost se vykreslit.

Jak je vidět u Unity i MonoGame, komponenty bývají často reprezentovány jako třídy, které dědí od abstraktního předka. To jim umožňuje provést přetížení některých funkcí, které na sobě předek definuje. Ovšem to má za následek, že implementace návrhového vzoru Component je závislá na volání virtualních funkcí, které může být výkonostně neefektivní.

Další výkonostní probém je neefektivní využívání paměti. Jelikož jsou za potřebí virtuální funkce, je nutné jednotlivé komponenty reprezentovat jako pointery (nebo referenční typy). Tím pádem nevyužívají efektivně cache. Více o tomto si povíme v \xxx{dalsi kapitola?}.

Dalším problémem návrhového vzoru Component je komunikace mezi jednotlivými komponenty. Tato komunikace může být problematická. Více je prozkoumána v~\citet{nystrom2014game}. Jedním z přístupů jak komunikaci mezi komponenty vyřešit je, že si z jedné komponenty vezmem referenci na jinou komponentu. Tím zařídíme, že tyto komponenty můžem spolu komunikovat. Ovšem tím nám ale vznikne tight coupling \xxx{link}. Jedná se o situaci, kde dvě nebo více komponent (ne nutně komponent z návrhového vzoru Component nebo z ECS) je na sobě závislích. To může vyústit například v to, že pokud budem chtít provést změny v jedné komponentě, bude to vyžadovat provést změny také v jiné komponentě.
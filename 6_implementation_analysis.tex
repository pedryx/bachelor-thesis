% Proc jsem delali rozhodnuti kdyz vznikala ta implementace.
\chapter{Analýza implementace}
V této kapitole prozkoumáme jaké rozhodnutí byla udělána během implementace a odůvodníme jejich zvolení. První nahlédneme na abstrakční vrstvu a poté na samotnou hru.

% analyza abstrakce
\section{Analýza abstrakční vrstvy}
V této sekci si představíme knihovny, které budeme chtít měřit. Nahlédneme na jejich rozhraní a na základě toho odůvodníme rozhodnutí provedené při implementaci abstrakční vrstvy.

% - knihovny
\subsection{Měřené knihovny}
Než začneme provádět analýzu abstrakční vrstvy, musíme si nejprve představit jednotlivé knihovny, které budeme chtít měřit. Následně nahlédneme na jejich rozhraní, to nám pomůže při analýze abstrakční vrstvy.

% --- predstaveni knihoven
I přesto, že lze program použít pro měření velkého množství ECS knihoven pro C\#, omezíme se pouze na následující:

\begin{enumerate}
    \item Arch~\ref{Arch}
    \item DefaultEcs~\ref{DefaultEcs}
    \item Entitas~\ref{Entitas}
    \item HypEcs~\ref{HypEcs}
    \item LeoECS~\ref{LeoECS}
    \item \xxx{Pridat dalsi knihovny kdyz bude cas.}
\end{enumerate}

\xxx{ --- rozebrat interface knihoven}\\\\


\xxx{ - entity processor}\\\\
\xxx{ --- -> entity processor}\\\\
\xxx{ --- co je inline function call}\\\\
\xxx{ --- jak jej zaridit}\\\\
\xxx{ --- -> proto struktura a generika (IECSSystem)}\\\\

\xxx{ - IEntity (chceme bohate rozhrani, jak jsme si popisovali)}\\\\
\xxx{ - IWorld (nektere ECS knihovny potrebuji Update/Tick)}\\\\
\xxx{ - Component attribute}\\\\
\xxx{ - ECSFactory (proc types - zjednoduseni rozhrani)}\\\\

\xxx{ analyza hry}\\\\









\iffalse

\section{Implementace AI}

Nyní si rozebereme populární přístupy pro implementaci AI ve hrách.

Nejpřímočarejší způsob je použít stavové automaty.

Pokročitejší zpusob jsou behavior trees.

Další pokročitelší způsob je Goal Oriented Action Planning (GOAP).

Proč jsme zvolili behavior trees?

Chování AI agentů může být popsané také přímo v systémech.

Ne vždy je zřejmé co by mělo být součástí AI.

% \\
% \xxx{jaka jsou mozsnosti?}
% \\
% \xxx{- behavior trees}
% \\
% \xxx{- state machines}
% \\
% \xxx{- GOAP}
% \\
% \xxx{proc jsme zvolili behavior trees?}
% \\
% \xxx{behavior primo v systemech a proc jsme to nepouzili}
% \\
% \xxx{Co by melo byt rizeno AI a co ne?}
% \\
% \xxx{- tezba surovin: pripsani do inventare vs damage and drop system}
% \\
% \xxx{- zpracovani surovin: pripsani do inventare vs resource processing system}
% \\

\section{ECS}

Některé systémy v ECS reagují pouze pokud je pro danou entitu splněna určitá podmínka.

Na první pohled by se mohlo zdát, že jsou tyto systémy špatné, jelikož podmínka je drahá operace.

Alternativní a pravděpodobně lepší způsob je použít eventy.

Rozeberme si jak by se s eventy v ECS pracovalo.

Další způsob, jak by se tento problém dal řešit jsou Reaction systémy.

% \\
% \xxx{condition checking systems are ok}
% \\
% \xxx{eventy v ECS}
% \\

\section{Generovani terenu}

Rozeberme si dva přístupy pro generování terénu.

První způsob je generovat terén přímo na CPU.

Druhý způsob je pro generování terénu použít GPU.

% problem s path finding

Abychom si rozebrali řešení, bude nejprve nutné nejprve říci něco více o shaderech.

Compute shader můžem použít k řešení výše zmíněného problému.

% \xxx{GPU vs CPU}

\section{Abstrakční vrstva}

\xxx{TODO}
% Analyza abstakce
% Analyza jak pomoci toho udelat hru

\section{Inline entity processor}

Inlinování funkcí je optimalizace, při které je volání funkce nahrazeno jejím obsahem.

% priklad, kdy dochazi k inlinovani

Kvůli měření je důležité, aby naše entity processory neměli ideálně žádný overhead.

Pro inlinování entity processorů, využíváma následujicí techniky.

% aggresive inlining, struktura + generika

% \\
% \xxx{Proc je to potreba}
% \\
% \xxx{Jak jsme toho dosahli}
% \\

\fi
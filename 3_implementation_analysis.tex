% Proc jsem delali rozhodnuti kdyz vznikala ta implementace.
\chapter{Analýza implementace}
V této kapitole prozkoumáme jaké rozhodnutí byla udělána během implementace a odůvodníme jejich zvolení. Prvně nahlédneme na abstrakční vrstvu a poté na samotnou hru.

% analyza abstrakce
\section{Analýza abstrakční vrstvy}
Abstrakční vrstva pro nás je důležitá, jelikož chceme aby naše hra byla nezávislá na konkrétní ECS knihovně. Program jako takový bude pracovat namísto ECS knihovny pouze s touto abstrakční vrstvou. Pro každou ECS knihovnu, kterou budeme měřit bude nutné vytvořit implementaci této vrstvy. K volbě konkrétní ECS knihovny dojde před spuštěním programu.

\subsection{Rozhraní ECS knihoven}
Potřebujeme rozebrat, abychom navrhli abstrakci, která bude podporovat různé ECS knihovny.

Běžné prvky v rozhraní.

\begin{enumerate}
    \item Entity
    \item Component
    \item World
    \item System
    \item Query
\end{enumerate}

Systémy reprezentovány různě.

\begin{enumerate}
    \item \verb|world.Query((entity) => { /**/ })|
    \item \verb|world.Query((comp1, comp2) => { /**/ })|
    \item \verb|world.Query((comp1[], comp2[]) => { /**/ })|
    \item \verb|void Update(entity) { /**/ }|
    \item \verb|void Update(comp1, comp2) { /**/ }|
    \item \verb|void Update(comp1[], comp2[]) { /**/ }|
    \item \verb|foreach (entity in entities) { /**/ }|
    \item \verb|foreach ((comp1, comp2) in entities) { /**/ }|
    \item \verb|for (int i = 0; i < 0; i++) { comp1[i], comp2[i], /**/ }|
\end{enumerate}

EntityProcessor jako řešení různých reprezentací systémů.

\subsection{Reprezentace systémů}
Prvně inlinování funkce, protože výkon věc z požadavků.

Co je inlinování funkce.

Kdy je funkce inlinovaná,

Generika a struktura jako řešení.

\subsection{Component tag}
Některé ECS knihovny potřebují před spuštěním hry vědět o typech komponent.

Component tag jako řešení.

\subsection{ECSFactory}
Je nějak potřeba konstruovat implementace tříd z abstrakční vrstvy.

Konstrukce systémů je ukecaná.

ECSFactory jako řešení.

\section{Analýza hry}
Budeme chtít používat ai pro chování vesničanů.

\subsection{Umělá inteligence}
Způsoby reprezentace ai:

\begin{enumerate}
    \item Stavové automaty
    \item Stromy chování
    \item GOAP
\end{enumerate}

Proč jsme zvolili stromy chování.

Použili jsme knihovnu na stromy chování.

Umělou inteligenci je možné definovat také v systémech.

Ne vždy je zřejmé co by mělo či nemělo být součástí umělé inteligence.

Tezba surovin: připsání do inventáře vs damage and drop systém.

Zpracování surovin: připsání do inventáře vs resource processing systém. 

\subsection{ECS}
Některé systémy proběhnou pro danou entitu pouze pokud je pro ní splněna určitá podmínka.

Podmínka je drahá operace protože pipeline flush.

Řešením můžou být eventy. EventQueue, EventReader/EventWriter, csharp events.

Další možné řešení jsou reaction systémy.

Proč eventy a reaction systémy nemůžeme použít. Proč nepoužíváme csharp eventy.

Proč tyto systémy nezpůsobují výkonnostní potíže při správných podmínkách (+ ty podmínky).

\subsection{Procedurální terén}
Terén generován pomocí simple noise.

\subsubsection{Generování terénu na CPU}
Zápis do jedné nebo více textur.

Rozmazání při přiblížení nebo oddálení.

Může trvat dlouho.

\subsubsection{Generování terénu na GPU}
Shadery jsou programy pro GPU. V této práci použijeme fragment shader a compute shader.

Shader pro generování terénu.

Je možné libovolně přiblížit nebo oddálit.

Provádíme za běhu a velmi rychle.

Z právě techto důvodů GPU.

\subsection{Path-finding pro vygenerovaný terén}
Při CPU přístupu by stačilo číst z textury.

Chceme pěkné cesty, takže výslednou cestu zkrášlujeme.

Vygenerovat texturu by trvalo dlouho, proto použijeme compute shader.

Zvolíme rozlišení, které předsamplujeme do pole, ve kterém poté provádíme path-finding.

Generování může trvat, protože přesun dat mezi GPU a CPU je drahý.

Je nutné použít fork MonoGame, který podporuje compute shadery.












% \subsection{Reprezentace systémů}
% Jak již bylo zmíněno v úvodu, velký problém při návrhu systémů je rozdílné rozhrani, které pro systémy jednotlivé ecs knihovny nabízejí.

% Dále, jak již jsme si zmiňovali v podkapitole o herních požadavcích, chceme aby se výkon naší hry při použití této abstrakční vrstvy blížil výkonu s použitím pouze samotné ecs knihovny.

% Nahlédneme na oba tyto problémy blíže a prozkoumáme jak jsme je vyřešili.

% \subsubsection{Rozhraní ecs knihoven}
% ECS knihovny reprezentují systémy následujícími způsoby:

% \begon{ordering}
% \item \xxx{TODO}
% \end{ordering}











% V této sekci si představíme knihovny, které budeme chtít měřit. Nahlédneme na jejich rozhraní a na základě toho odůvodníme rozhodnutí provedené při implementaci abstrakční vrstvy.

% % - knihovny
% \subsection{Měřené knihovny}
% Než začneme provádět analýzu abstrakční vrstvy, musíme si nejprve představit jednotlivé knihovny, které budeme chtít měřit. Následně nahlédneme na jejich rozhraní, to nám pomůže při analýze abstrakční vrstvy.

% % --- predstaveni knihoven
% I přesto, že lze program použít pro měření velkého množství ECS knihoven pro C\#, omezíme se pouze na následující:

% \begin{enumerate}
%     \item Arch~\cite{Arch}
%     \item DefaultEcs~\cite{DefaultEcs}
%     \item Entitas~\cite{Entitas}
%     \item HypEcs~\cite{HypEcs}
%     \item LeoECS~\cite{LeoECS}
%     \item \xxx{Pridat dalsi knihovny kdyz bude cas.}
% \end{enumerate}

% \xxx{ --- rozebrat interface knihoven}\\\\

% \section{Inline entity processor}

% Inlinování funkcí je optimalizace, při které je volání funkce nahrazeno jejím obsahem.

% % priklad, kdy dochazi k inlinovani

% Kvůli měření je důležité, aby naše entity procesory neměli ideálně žádný overhead.

% Pro inlinování entity procesorů, využíváme následující techniky.

% % aggressive inlining, struktura + generika

% % \\
% % \xxx{Proc je to potreba}
% % \\
% % \xxx{Jak jsme toho dosahli}
% % \\

% \xxx{ - entity processor}\\\\
% \xxx{ --- -> entity processor}\\\\
% \xxx{ --- co je inline function call}\\\\
% \xxx{ --- jak jej zaridit}\\\\
% \xxx{ --- -> proto struktura a generika (IECSSystem)}\\\\

% \xxx{ - IEntity (chceme bohate rozhrani, jak jsme si popisovali)}\\\\
% \xxx{ - IWorld (nektere ECS knihovny potrebuji Update/Tick)}\\\\
% \xxx{ - Component attribute}\\\\
% \xxx{ - ECSFactory (proc types - zjednoduseni rozhrani)}\\\\

% \section{Analýza hry}

% text

% \subsection{Implementace AI}

% Nyní si rozebereme populární přístupy pro implementaci AI ve hrách.

% Nejpřímočařejší způsob je použít stavové automaty.

% Pokročilejší zpusob jsou behavior trees.

% Další pokročilejší způsob je Goal Oriented Action Planning (GOAP).

% Proč jsme zvolili behavior trees?

% Chování AI agentů může být popsané také přímo v systémech.

% Ne vždy je zřejmé co by mělo být součástí AI.

% \\
% \xxx{jaka jsou mozsnosti?}
% \\
% \xxx{- behavior trees}
% \\
% \xxx{- state machines}
% \\
% \xxx{- GOAP}
% \\
% \xxx{proc jsme zvolili behavior trees?}
% \\
% \xxx{behavior primo v systemech a proc jsme to nepouzili}
% \\
% \xxx{Co by melo byt rizeno AI a co ne?}
% \\
% \xxx{- tezba surovin: pripsani do inventare vs damage and drop system}
% \\
% \xxx{- zpracovani surovin: pripsani do inventare vs resource processing system}
% \\

% \subsection{ECS}

% Některé systémy v ECS reagují pouze pokud je pro danou entitu splněna určitá podmínka.

% Na první pohled by se mohlo zdát, že jsou tyto systémy špatné, jelikož podmínka je drahá operace.

% Alternativní a pravděpodobně lepší způsob je použít eventy.

% Rozeberme si jak by se s eventy v ECS pracovalo.

% Další způsob, jak by se tento problém dal řešit jsou Reaction systémy.

% \\
% \xxx{condition checking systems are ok}
% \\
% \xxx{eventy v ECS}
% \\

% \subsection{Generovani terenu}

% Rozeberme si dva přístupy pro generování terénu.

% První způsob je generovat terén přímo na CPU.

% Druhý způsob je pro generování terénu použít GPU.

% problem s path finding

% Abychom si rozebrali řešení, bude nejprve nutné nejprve říci něco více o shaderech.

% Compute shader můžeme použít k řešení výše zmíněného problému.

% \xxx{GPU vs CPU}
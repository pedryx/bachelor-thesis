% game code changes more often than code in other industries

\chapter{Architektury her}
V této kapitole si rozeberem architektury, které lze využít pro vývoj her. Pomůže nám to lépe porozumět problémům, které ECS řeší. Začneme objektovým návrhem a prozkoumáme problémy spojené s dědičností při vývoji her. Následně se zaměříme na návrhový vzor Component, který se snaží řešit tuto problematiku, a nahlédneme proč komunikace mezi komponentami může být problematická.

Proto abychom lépe porozuměli herním architekturám, bude nutné si nejprve přiblížit jak se tvorba her liší od tvorby běžního software.
% Popsat iterativni vyvoj

% \xxx{navrhovy vzor x architektura}.

\section{Objektový návrh}
Objektový návrh je ... .

Nýní si navrhněme jednoduchou hru, na které si přiblížíme problémy s dědičností, které mohou při vývoji her s objektovým návrhem nastat.
%Za účelem detailnějšího porozumění problematiky dědičnosti si pomocí objektového návrhu navrhneme jednoduchou hru. Začneme implementací třídy GameObject, sloužící jako předek pro libovolný objekt ve scéně. Dále se rozhodnem do naší hry přidat jednotku lučištníka. Přidáváme tedy třídu Archer, která dědí od GameObject. Následně se rozhodujeme rozšířit naši hru o věž. Přidáváme tedy třídu Tower, dědicí od GameObject. Následně se rozhodnem, že chceme aby naše věž uměla střílet, proto pro třidu Tower implementujem střelbu. Ovšem střelbu jsme již určitě implementovali do třídy Archer, což nám nyní vytváří duplicitní kód.
% do prikladu popridavat veci z prikladu nize

Jak tento problém vyřešit? Prvním přístupem je využití multiple inheritance \xxx{link}.
%Jak tento problém vyřešit? Prvním přístupem je využití multiple inheritance. Pokud programovací jazyk povoluje multiple inheritance, umožňuje to jedné třídě mít více než jednoho předka. Vytvořením společného předka ShootableObject, který by obsahoval společný kód střelby jak pro věž tak pro lučišníka, by byl duplicitní kód eliminován. Ovšem s povolením multiple inheritance se může objevit tzv. diamond problem, kdy dochází k problémům při přístupu ke členům definovaným na společném předkovi, pokud třída dědí od dvou tříd s tímto společným předkem.

Alternativním přístupem by mohlo být přesunutí logiky střelby do třídy GameObject.
%, což však narušuje princip single responsibility, jenž uvádí, že každá třída by měla být odpovědná pouze za jednu funkcionalitu. Porušením tohoto principu by se v průběhu času mohlo projevit hromaděním logiky v této třídě, vedoucí k vytvoření obrovské třídy (tzv. Blob Object Problem).

Další problém je, že náš návrh je příliš závislý na hierarchii dědičnosti (tzv. tight coupling \xxx{link}), což omezuje náš design hry.
%V praxi to znamená, že např. není možné za běhu přidat objektu schopnost střílet. Řešením celé této situace je koncept Composition over Inheritance. Místo tradiční dědičnosti preferujeme rozdělení objektů na komponenty.

\section{Návrhový vzor Component}
Component je návrhový vzor... .

Tento návrhový vzor je velice populární.

Nyní si rozeberme problemy, které mohou vzniknout při používání návrhového vzoru Component.

Příklad?
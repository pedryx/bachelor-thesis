% Proc jsem delali rozhodnuti kdyz vznikala ta implementace.
\chapter{Analýza implementace}
V této kapitole prozkoumáme jaké rozhodnutí byla udělána během implementace a odůvodníme jejich zvolení. Prvně nahlédneme na abstrakční vrstvu a poté na samotnou hru.

% analyza abstrakce
\section{Analýza abstrakční vrstvy}
Abstrakční vrstva pro nás je důležitá, jelikož chceme aby naše hra byla nezávislá na konkrétní ECS knihovně. Program jako takový bude pracovat namísto ECS knihovny pouze s touto abstrakční vrstvou. Pro každou ECS knihovnu, kterou budeme měřit bude nutné vytvořit implementaci této vrstvy. K volbě konkrétní ECS knihovny dojde před spuštěním programu.

\subsection{Rozhraní ECS knihoven}
Pro návrh abstrakční vrstvy bude nejprve nutné rozebrat jak jsou jednotlivé prvky ECS reprezentovány při jejich implementaci. Krom základních členů, jako jsou \textit{entity}, \textit{komponenty} a \textit{systémy}, si představíme ještě \textit{world} a \textit{query}.

\begin{enumerate}
    \item \textbf{Component} \textit{Komponenty}, jako takové, bývají často reprezentovány třídou nebo strukturou. Jak již bylo zmíněno v úvodu, \textit{komponenty} obsahují pouze data, nikoliv žádnou logiku. Proto tyto třídy a struktury neobsahují žádné funkce.

    \item \textbf{Entity} \textit{Entita} by, podobně jako v návrhovém vzoru Component, mohla být reprezentována jako kolekce svých \textit{komponent}. Ovšem to se v praxi nedělá, namísto toho se používá řešení, které vede k lepšímu výkonu. Většina ECS implementacích reprezentuje \textit{entity} pouze jako jednoduchý identifikátor a jednotlivé \textit{komponenty} jsou na \textit{entity} mapovány skrze \textit{world}.

    \item \textbf{World} \textit{World} je spravce \textit{entit} a \text{komponent}. Tento správce slouží jako kontejner pro všechny \textit{entity} a \textit{komponenty} v herním světě. Jeho rozhraní nabízí funkce, pomocí niž je možné vytvářet a mazat jednotlivé entity. Často obsahuje také funkce pro přidávání a odebírání komponent jednotlivým entitám.

    Některé ECS implementace reprezentují entity pomocí malé struktury, obsahující identifikátor dané entity společně s referencí na world do kterého patří. To umožňuje mít na této struktuře bohaté rozhraní s funkcemi pro přidávání a odebírání komponent.

    \item \textbf{System} Reprezentace \textit{systémů} se v jednotlivých ECS implementacích dost liší. Některé vyžadují aby \textit{systém} byl třída dědicí od abstraktního předka, jiné zase volí opačný extrém a dovolují \textit{systém} reprezentovat téměř jakkoliv. Navzdory velkým odlišnostem se ve velkém počtu ECS implementací často objevuje objekt, který mohou používat jednotlivé systémy pro iterování entit s určitou množinou komponent.

    \item \textbf{Query} \textit{Query} je objekt, který lze použít pro iterování \textit{entit} s určitou množinou \textit{komponent}. Pro jeho vytvoření je většinou nutné poskytnou informaci, nad jakými typy \textit{komponent} bude \textit{query} pracovat. Je například možné mít \textit{query}, které pracuje nad \textit{komponentami} \verb|Movement| a \verb|Position|. Takové \textit{query} by pak bylo schopné iterovat nad všemi \textit{entitami} co mají \textit{komponenty} \verb|Movement| a \verb|Position|. Pomocí tohoto \textit{query} by bylo možné implementovat \verb|MovementSystem|, který by řídil logiku pohybu.
\end{enumerate}

Jak již bylo zmíněno, způsoby jakými jednotlivé ECS knihovny reprezentují \textit{systémy} se dost liší. Rozeberme si nyní tyto způsoby.

\begin{enumerate}
    \item \verb|Query((entity) => { /**/ })|
    \item \verb|Query((component1, component2) => { /**/ })|
    \item \verb|Query((components1[], components2[]) => { /**/ })|
    \item \verb|void Update(entity) { /**/ }|
    \item \verb|void Update(component1, component2) { /**/ }|
    \item \verb|void Update(components1[], components2[]) { /**/ }|
    \item \verb|foreach (entity in entities) { /**/ }|
    \item \verb|foreach ((component1, component2) in entities) { /**/ }|
    \item \verb|for (int i = 0; i < entitiesCount; i++)|\\\verb|{ components1[i], components2[i], /**/ }|
\end{enumerate}

Jak je možné vidět tyto způsoby lze rozdělit do tří kategorií.

Do první kategorie spadají způsoby 1--3. Knihovny, které využívají tyto způsoby mají většinou definovanou metodu \verb|Query| (neplést s \textit{query} jako objektem pro iterování \textit{entit}). Tato metoda bývá často implementována na \textit{query} nebo na \textit{world}. Této metodě se předává lambda funkce, která je v případě 1 volána na každou iterovanou \textit{entitu}, v případě 2 volána na množinu žádoucích instancí \textit{komponent} každé iterované \textit{entity}, v případě 3 volána na množinu polí, které obsahují žádoucí instance \textit{komponent} a kde jako index do těchto polí lze použít identifikátor příslušné \textit{entity}.

Způsoby z druhé kategorie vyžadují aby \textit{systém} byl třída, dědicí od rozhraní nebo předka. Toto rozhraní nebo předek nabízí abstraktní metodu \verb|Update|, kterou je nutné přetížit. Do této kategorie spadají způsoby 4--6. Při iteraci je v případě 4 metoda \verb|Update| volána na každou iterovanou \textit{entitu}, v případě 5 na množinu žádoucích instancí \textit{komponent} každé iterované \textit{entity}, v případě 6 na množinu polí, které obsahují žádoucí instance \textit{komponent} a kde jako index do těchto polí lze použít identifikátor příslušné \textit{entity}.

Třetí kategorie nabízí kolekce nebo iterátory, které lze iterovat. Tyto kolekce nebo iterátory lze získat voláním příslušné funkce na \textit{world} nebo \textit{query}. Do této kategorie spadají způsoby 7--9. V případě 7 tato kolekce nebo iterátor obsahuje všechny \textit{entity}, které chceme iterovat. V případě 8 tato kolekce nebo iterátor obsahuje n-tice žádoucích instancí \textit{komponent} každé iterované \textit{entity}. V případě 9 je namísto kolekce použita množina polí, které obsahují žádoucí instance \textit{komponent} a kde jako index do těchto polí lze použít identifikátor příslušné \textit{entity}.

\subsection{Reprezentace systémů}
Jak reprezentujeme knihovny v abstrakční vrstvě.

Prvně inlinování funkce, protože výkon věc z požadavků.

Co je inlinování funkce.

Kdy je funkce inlinovaná,

Generika a struktura jako řešení.

\subsection{Component tag}
Některé ECS knihovny potřebují před spuštěním hry vědět o typech komponent.

Component tag jako řešení.

\subsection{ECSFactory}
Je nějak potřeba konstruovat implementace tříd z abstrakční vrstvy.

Konstrukce systémů je ukecaná.

ECSFactory jako řešení.

\section{Analýza hry}
Budeme chtít používat ai pro chování vesničanů.

\subsection{Umělá inteligence}
Způsoby reprezentace ai:

\begin{enumerate}
    \item Stavové automaty
    \item Stromy chování
    \item GOAP
\end{enumerate}

Proč jsme zvolili stromy chování.

Použili jsme knihovnu na stromy chování.

Umělou inteligenci je možné definovat také v systémech.

Ne vždy je zřejmé co by mělo či nemělo být součástí umělé inteligence.

Tezba surovin: připsání do inventáře vs damage and drop systém.

Zpracování surovin: připsání do inventáře vs resource processing systém. 

\subsection{ECS}
Některé systémy proběhnou pro danou entitu pouze pokud je pro ní splněna určitá podmínka.

Podmínka je drahá operace protože pipeline flush.

Řešením můžou být eventy. EventQueue, EventReader/EventWriter, csharp events.

Další možné řešení jsou reaction systémy.

Proč eventy a reaction systémy nemůžeme použít. Proč nepoužíváme csharp eventy.

Proč tyto systémy nezpůsobují výkonnostní potíže při správných podmínkách (+ ty podmínky).

\subsection{Procedurální terén}
Terén generován pomocí simplex noise.

\subsubsection{Generování terénu na CPU}
Zápis do jedné nebo více textur.

Rozmazání při přiblížení nebo oddálení.

Může trvat dlouho.

\subsubsection{Generování terénu na GPU}
Shadery jsou programy pro GPU. V této práci použijeme fragment shader a compute shader.

Shader pro generování terénu.

Je možné libovolně přiblížit nebo oddálit.

Provádíme za běhu a velmi rychle.

Z právě techto důvodů GPU.

\subsection{Path-finding pro vygenerovaný terén}
Při CPU přístupu by stačilo číst z textury.

Chceme pěkné cesty, takže výslednou cestu zkrášlujeme.

Vygenerovat texturu by trvalo dlouho, proto použijeme compute shader.

Zvolíme rozlišení, které předsamplujeme do pole, ve kterém poté provádíme path-finding.

Generování může trvat, protože přesun dat mezi GPU a CPU je drahý.

Je nutné použít fork MonoGame, který podporuje compute shadery.












% \subsection{Reprezentace systémů}
% Jak již bylo zmíněno v úvodu, velký problém při návrhu systémů je rozdílné rozhrani, které pro systémy jednotlivé ecs knihovny nabízejí.

% Dále, jak již jsme si zmiňovali v podkapitole o herních požadavcích, chceme aby se výkon naší hry při použití této abstrakční vrstvy blížil výkonu s použitím pouze samotné ecs knihovny.

% Nahlédneme na oba tyto problémy blíže a prozkoumáme jak jsme je vyřešili.

% \subsubsection{Rozhraní ecs knihoven}
% ECS knihovny reprezentují systémy následujícími způsoby:

% \begon{ordering}
% \item \xxx{TODO}
% \end{ordering}











% V této sekci si představíme knihovny, které budeme chtít měřit. Nahlédneme na jejich rozhraní a na základě toho odůvodníme rozhodnutí provedené při implementaci abstrakční vrstvy.

% % - knihovny
% \subsection{Měřené knihovny}
% Než začneme provádět analýzu abstrakční vrstvy, musíme si nejprve představit jednotlivé knihovny, které budeme chtít měřit. Následně nahlédneme na jejich rozhraní, to nám pomůže při analýze abstrakční vrstvy.

% % --- predstaveni knihoven
% I přesto, že lze program použít pro měření velkého množství ECS knihoven pro C\#, omezíme se pouze na následující:

% \begin{enumerate}
%     \item Arch~\cite{Arch}
%     \item DefaultEcs~\cite{DefaultEcs}
%     \item Entitas~\cite{Entitas}
%     \item HypEcs~\cite{HypEcs}
%     \item LeoECS~\cite{LeoECS}
%     \item \xxx{Pridat dalsi knihovny kdyz bude cas.}
% \end{enumerate}

% \xxx{ --- rozebrat interface knihoven}\\\\

% \section{Inline entity processor}

% Inlinování funkcí je optimalizace, při které je volání funkce nahrazeno jejím obsahem.

% % priklad, kdy dochazi k inlinovani

% Kvůli měření je důležité, aby naše entity procesory neměli ideálně žádný overhead.

% Pro inlinování entity procesorů, využíváme následující techniky.

% % aggressive inlining, struktura + generika

% % \\
% % \xxx{Proc je to potreba}
% % \\
% % \xxx{Jak jsme toho dosahli}
% % \\

% \xxx{ - entity processor}\\\\
% \xxx{ --- -> entity processor}\\\\
% \xxx{ --- co je inline function call}\\\\
% \xxx{ --- jak jej zaridit}\\\\
% \xxx{ --- -> proto struktura a generika (IECSSystem)}\\\\

% \xxx{ - IEntity (chceme bohate rozhrani, jak jsme si popisovali)}\\\\
% \xxx{ - IWorld (nektere ECS knihovny potrebuji Update/Tick)}\\\\
% \xxx{ - Component attribute}\\\\
% \xxx{ - ECSFactory (proc types - zjednoduseni rozhrani)}\\\\

% \section{Analýza hry}

% text

% \subsection{Implementace AI}

% Nyní si rozebereme populární přístupy pro implementaci AI ve hrách.

% Nejpřímočařejší způsob je použít stavové automaty.

% Pokročilejší zpusob jsou behavior trees.

% Další pokročilejší způsob je Goal Oriented Action Planning (GOAP).

% Proč jsme zvolili behavior trees?

% Chování AI agentů může být popsané také přímo v systémech.

% Ne vždy je zřejmé co by mělo být součástí AI.

% \\
% \xxx{jaka jsou mozsnosti?}
% \\
% \xxx{- behavior trees}
% \\
% \xxx{- state machines}
% \\
% \xxx{- GOAP}
% \\
% \xxx{proc jsme zvolili behavior trees?}
% \\
% \xxx{behavior primo v systemech a proc jsme to nepouzili}
% \\
% \xxx{Co by melo byt rizeno AI a co ne?}
% \\
% \xxx{- tezba surovin: pripsani do inventare vs damage and drop system}
% \\
% \xxx{- zpracovani surovin: pripsani do inventare vs resource processing system}
% \\

% \subsection{ECS}

% Některé systémy v ECS reagují pouze pokud je pro danou entitu splněna určitá podmínka.

% Na první pohled by se mohlo zdát, že jsou tyto systémy špatné, jelikož podmínka je drahá operace.

% Alternativní a pravděpodobně lepší způsob je použít eventy.

% Rozeberme si jak by se s eventy v ECS pracovalo.

% Další způsob, jak by se tento problém dal řešit jsou Reaction systémy.

% \\
% \xxx{condition checking systems are ok}
% \\
% \xxx{eventy v ECS}
% \\

% \subsection{Generovani terenu}

% Rozeberme si dva přístupy pro generování terénu.

% První způsob je generovat terén přímo na CPU.

% Druhý způsob je pro generování terénu použít GPU.

% problem s path finding

% Abychom si rozebrali řešení, bude nejprve nutné nejprve říci něco více o shaderech.

% Compute shader můžeme použít k řešení výše zmíněného problému.

% \xxx{GPU vs CPU}